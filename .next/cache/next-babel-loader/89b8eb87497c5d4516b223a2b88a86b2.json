{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useCallback, useState, useMemo, useEffect } from \"react\";\nimport { useInterval } from \"../hooks/use-interval\";\nimport { usePrevious } from \"../hooks/use-previous\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\nexport var useTimer = function useTimer(userSteps) {\n  _s();\n\n  // // Add a \"start\" field to every step that was passed in so we\n  // // can determine which step is the current:\n  var steps = useMemo(function () {\n    return userSteps.map(function (step, i) {\n      return _objectSpread(_objectSpread({}, step), {}, {\n        // We convert step duration, which is configured in seconds,\n        // to milliseconds here. This overwrites the original duration\n        // value!\n        duration: step.duration * 1000,\n        // The start is determined by the sum of all durations of\n        // the previous steps. Once these durations have passed,\n        // the current step is active. Finally, subtract 1000 milliseconds\n        // to always start a round \"early\".\n        start: userSteps.slice(0, i).reduce(function (total, _ref) {\n          var duration = _ref.duration;\n          return total + duration * 1000;\n        }, 0) - 1000\n      });\n    });\n  }, [userSteps.length]); // Store whether the timer is running in state:\n\n  var _useState = useState(false),\n      isRunning = _useState[0],\n      setIsRunning = _useState[1]; // Store both current and previous tick timestamps so we can\n  // compute the difference between them:\n\n\n  var _useState2 = useState(0),\n      currentTick = _useState2[0],\n      setCurrentTick = _useState2[1];\n\n  var previousTick = usePrevious(currentTick); // Store total elapsed time in state:\n\n  var _useState3 = useState(0),\n      elapsed = _useState3[0],\n      setElapsed = _useState3[1]; // Compute the total time needed to complete this timer:\n\n\n  var totalTime = useMemo(function () {\n    return sum(valuesForKey(userSteps, \"duration\")) * 1000;\n  }, [userSteps.length]); // Compute the remaining time:\n\n  var remaining = useMemo(function () {\n    return totalTime - elapsed;\n  }, [elapsed]); // // Determine whether the timer is complete:\n\n  var isComplete = useMemo(function () {\n    return remaining === 0;\n  }, [remaining]); // // Compute the current step's index:\n\n  var currentStepIndex = useMemo(function () {\n    // find the index of the first step that we find of which we have not yet\n    // passed the start moment:\n    var index = steps.findIndex(function (_ref2) {\n      var start = _ref2.start;\n      return elapsed < start;\n    });\n    console.log(index); // If found, the current step is the step before the one we found:\n\n    if (index !== -1) return index - 1; // If not found, we're on the last step:\n\n    return steps.length;\n  }, [elapsed]); // // Compute how much time is remaining in the current step\n\n  var currentStepRemaining = useMemo(function () {\n    // Get the sum of durations of all previous steps (excluding current):\n    var totalPreviousSteps = sum(valuesForKey(steps.slice(0, currentStepIndex), \"duration\")); // Compute the progress within the current step:\n\n    var progressCurrentStep = elapsed - totalPreviousSteps; // Subtract the progress within this step from the total duration:\n\n    return steps[currentStepIndex].duration - progressCurrentStep;\n  }, [currentStepIndex, elapsed]); // Every tick, update the current tick in state:\n\n  var tick = function tick() {\n    return setCurrentTick(Date.now());\n  }; // Tick every 100 millisecons when timer is running:\n\n\n  useInterval(tick, isRunning && !isComplete ? 100 : null); // Update the total elapsed time by adding the difference\n  // between the current and the previous tick to the previous total:\n\n  useEffect(function () {\n    // Don't update if we're not running:\n    if (!isRunning) return; // Don't update if the previous tick was 0:\n\n    if (!previousTick || previousTick === 0) return;\n    setElapsed(function (elapsed) {\n      return elapsed + (currentTick - previousTick);\n    });\n  }, [currentTick]); // Expose a method to reset the timer:\n\n  var reset = useCallback(function () {\n    setIsRunning(false);\n    setElapsed(0);\n    setCurrentTick(0);\n  }, []); // Expose a method to start the timer:\n\n  var start = useCallback(function () {\n    setCurrentTick(Date.now());\n    setIsRunning(true);\n  }, []); // Expose a method to stop (pause) the timer:\n\n  var stop = useCallback(function () {\n    setIsRunning(false); // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n\n    setCurrentTick(0);\n  }, []); // Expose a method to toggle the timer:\n\n  var toggle = useCallback(function () {\n    if (isRunning) return stop();\n    return start();\n  }, [isRunning]);\n  return {\n    currentStepIndex: currentStepIndex,\n    currentStepRemaining: currentStepRemaining,\n    elapsed: elapsed,\n    isComplete: isComplete,\n    isRunning: isRunning,\n    remaining: remaining,\n    reset: reset,\n    start: start,\n    stop: stop,\n    toggle: toggle\n  };\n};\n\n_s(useTimer, \"BGqtAGUMXs+yNAH84oP19zy1tUw=\", false, function () {\n  return [usePrevious, useInterval];\n});","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useEffect","useInterval","usePrevious","sum","valuesForKey","useTimer","userSteps","steps","map","step","i","duration","start","slice","reduce","total","length","isRunning","setIsRunning","currentTick","setCurrentTick","previousTick","elapsed","setElapsed","totalTime","remaining","isComplete","currentStepIndex","index","findIndex","console","log","currentStepRemaining","totalPreviousSteps","progressCurrentStep","tick","Date","now","reset","stop","toggle"],"mappings":"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","sourcesContent":["import { useCallback, useState, useMemo, useEffect } from \"react\";\n\nimport { useInterval } from \"../hooks/use-interval\";\nimport { usePrevious } from \"../hooks/use-previous\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\nexport const useTimer = (userSteps: Step[]) => {\n    // // Add a \"start\" field to every step that was passed in so we\n    // // can determine which step is the current:\n    const steps = useMemo(\n        () =>\n            userSteps.map((step, i) => ({\n                // We copy the original step as not to lose any nformation.\n                ...step,\n\n                // We convert step duration, which is configured in seconds,\n                // to milliseconds here. This overwrites the original duration\n                // value!\n                duration: step.duration * 1000,\n\n                // The start is determined by the sum of all durations of\n                // the previous steps. Once these durations have passed,\n                // the current step is active. Finally, subtract 1000 milliseconds\n                // to always start a round \"early\".\n                start:\n                    userSteps\n                        .slice(0, i)\n                        .reduce(\n                            (total, { duration }) => total + duration * 1000,\n                            0\n                        ) - 1000,\n            })),\n        [userSteps.length]\n    );\n\n    // Store whether the timer is running in state:\n    const [isRunning, setIsRunning] = useState(false);\n\n    // Store both current and previous tick timestamps so we can\n    // compute the difference between them:\n    const [currentTick, setCurrentTick] = useState(0);\n    const previousTick = usePrevious(currentTick);\n\n    // Store total elapsed time in state:\n    const [elapsed, setElapsed] = useState(0);\n\n    // Compute the total time needed to complete this timer:\n    const totalTime = useMemo(\n        () => sum(valuesForKey(userSteps, \"duration\")) * 1000,\n        [userSteps.length]\n    );\n\n    // Compute the remaining time:\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n\n    // // Determine whether the timer is complete:\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // // Compute the current step's index:\n    const currentStepIndex = useMemo(() => {\n        // find the index of the first step that we find of which we have not yet\n        // passed the start moment:\n        const index = steps.findIndex(({ start }) => elapsed < start);\n\n        console.log(index);\n\n        // If found, the current step is the step before the one we found:\n        if (index !== -1) return index - 1;\n\n        // If not found, we're on the last step:\n        return steps.length;\n    }, [elapsed]);\n\n    // // Compute how much time is remaining in the current step\n    const currentStepRemaining = useMemo(() => {\n        // Get the sum of durations of all previous steps (excluding current):\n        const totalPreviousSteps = sum(\n            valuesForKey(steps.slice(0, currentStepIndex), \"duration\")\n        );\n        // Compute the progress within the current step:\n        const progressCurrentStep = elapsed - totalPreviousSteps;\n\n        // Subtract the progress within this step from the total duration:\n        return steps[currentStepIndex].duration - progressCurrentStep;\n    }, [currentStepIndex, elapsed]);\n\n    // Every tick, update the current tick in state:\n    const tick = () => setCurrentTick(Date.now());\n\n    // Tick every 100 millisecons when timer is running:\n    useInterval(tick, isRunning && !isComplete ? 100 : null);\n\n    // Update the total elapsed time by adding the difference\n    // between the current and the previous tick to the previous total:\n    useEffect(() => {\n        // Don't update if we're not running:\n        if (!isRunning) return;\n\n        // Don't update if the previous tick was 0:\n        if (!previousTick || previousTick === 0) return;\n\n        setElapsed((elapsed) => elapsed + (currentTick - previousTick));\n    }, [currentTick]);\n\n    // Expose a method to reset the timer:\n    const reset = useCallback(() => {\n        setIsRunning(false);\n        setElapsed(0);\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to start the timer:\n    const start = useCallback(() => {\n        setCurrentTick(Date.now());\n        setIsRunning(true);\n    }, []);\n\n    // Expose a method to stop (pause) the timer:\n    const stop = useCallback(() => {\n        setIsRunning(false);\n        // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to toggle the timer:\n    const toggle = useCallback(() => {\n        if (isRunning) return stop();\n        return start();\n    }, [isRunning]);\n\n    return {\n        currentStepIndex,\n        currentStepRemaining,\n        elapsed,\n        isComplete,\n        isRunning,\n        remaining,\n        reset,\n        start,\n        stop,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}