{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback, useState, useMemo, useEffect } from \"react\";\nimport { useInterval } from \"../hooks/use-interval\";\nimport { usePrevious } from \"../hooks/use-previous\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\nexport const useTimer = userSteps => {\n  // // Add a \"start\" field to every step that was passed in so we\n  // // can determine which step is the current:\n  const steps = useMemo(() => userSteps.map((step, i) => _objectSpread(_objectSpread({}, step), {}, {\n    // We convert step duration, which is configured in seconds,\n    // to milliseconds here. This overwrites the original duration\n    // value!\n    duration: step.duration * 1000,\n    // The start is determined by the sum of all durations of\n    // the previous steps. Once these durations have passed,\n    // the current step is active. Finally, subtract 1000 milliseconds\n    // to always start a round \"early\".\n    start: userSteps.slice(0, i).reduce((total, {\n      duration\n    }) => total + duration * 1000, 0) - 1000\n  })), [userSteps.length]); // Store whether the timer is running in state:\n\n  const {\n    0: isRunning,\n    1: setIsRunning\n  } = useState(false); // Store both current and previous tick timestamps so we can\n  // compute the difference between them:\n\n  const {\n    0: currentTick,\n    1: setCurrentTick\n  } = useState(0);\n  const previousTick = usePrevious(currentTick); // Store total elapsed time in state:\n\n  const {\n    0: elapsed,\n    1: setElapsed\n  } = useState(0); // Compute the total time needed to complete this timer:\n\n  const totalTime = useMemo(() => sum(valuesForKey(userSteps, \"duration\")) * 1000, [userSteps.length]); // Compute the remaining time:\n\n  const remaining = useMemo(() => Math.max(totalTime - elapsed, 0), [elapsed]); // // Determine whether the timer is complete:\n\n  const isComplete = useMemo(() => remaining === 0, [remaining]); // // Compute the current step's index:\n\n  const currentStepIndex = useMemo(() => {\n    // find the index of the first step that we find of which we have not yet\n    // passed the start moment:\n    const index = steps.findIndex(({\n      start\n    }) => elapsed < start); // If found, the current step is the step before the one we found.\n    // If not found, we're on the last step.\n\n    return (index === -1 ? steps.length : index) - 1;\n  }, [elapsed]); // // Compute how much time is remaining in the current step\n\n  const currentStepRemaining = useMemo(() => {\n    // Get the sum of durations of all previous steps (excluding current):\n    const totalPreviousSteps = sum(valuesForKey(steps.slice(0, currentStepIndex), \"duration\")); // Compute the progress within the current step:\n\n    const progressCurrentStep = elapsed - totalPreviousSteps; // Subtract the progress within this step from the total duration:\n\n    return steps[currentStepIndex].duration - progressCurrentStep;\n  }, [currentStepIndex, elapsed]); // Every tick, update the current tick in state:\n\n  const tick = () => setCurrentTick(Date.now()); // Tick every 100 millisecons when timer is running:\n\n\n  useInterval(tick, isRunning && !isComplete ? 100 : null); // Update the total elapsed time by adding the difference\n  // between the current and the previous tick to the previous total:\n\n  useEffect(() => {\n    // Don't update if we're not running:\n    if (!isRunning) return; // Don't update if the previous tick was 0:\n\n    if (!previousTick || previousTick === 0) return;\n    setElapsed(elapsed => elapsed + (currentTick - previousTick));\n  }, [currentTick]); // Expose a method to reset the timer:\n\n  const reset = useCallback(() => {\n    setIsRunning(false);\n    setElapsed(0);\n    setCurrentTick(0);\n  }, []); // Expose a method to start the timer:\n\n  const start = useCallback(() => {\n    setCurrentTick(Date.now());\n    setIsRunning(true);\n  }, []); // Expose a method to stop (pause) the timer:\n\n  const stop = useCallback(() => {\n    setIsRunning(false); // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n\n    setCurrentTick(0);\n  }, []); // Expose a method to toggle the timer:\n\n  const toggle = useCallback(() => {\n    if (isRunning) return stop();\n    return start();\n  }, [isRunning]);\n  return {\n    currentStepIndex,\n    currentStepRemaining,\n    elapsed,\n    isComplete,\n    isRunning,\n    remaining,\n    reset,\n    start,\n    stop,\n    toggle\n  };\n};","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useEffect","useInterval","usePrevious","sum","valuesForKey","useTimer","userSteps","steps","map","step","i","duration","start","slice","reduce","total","length","isRunning","setIsRunning","currentTick","setCurrentTick","previousTick","elapsed","setElapsed","totalTime","remaining","Math","max","isComplete","currentStepIndex","index","findIndex","currentStepRemaining","totalPreviousSteps","progressCurrentStep","tick","Date","now","reset","stop","toggle"],"mappings":"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","sourcesContent":["import { useCallback, useState, useMemo, useEffect } from \"react\";\n\nimport { useInterval } from \"../hooks/use-interval\";\nimport { usePrevious } from \"../hooks/use-previous\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\nexport const useTimer = (userSteps: Step[]) => {\n    // // Add a \"start\" field to every step that was passed in so we\n    // // can determine which step is the current:\n    const steps = useMemo(\n        () =>\n            userSteps.map((step, i) => ({\n                // We copy the original step as not to lose any nformation.\n                ...step,\n\n                // We convert step duration, which is configured in seconds,\n                // to milliseconds here. This overwrites the original duration\n                // value!\n                duration: step.duration * 1000,\n\n                // The start is determined by the sum of all durations of\n                // the previous steps. Once these durations have passed,\n                // the current step is active. Finally, subtract 1000 milliseconds\n                // to always start a round \"early\".\n                start:\n                    userSteps\n                        .slice(0, i)\n                        .reduce(\n                            (total, { duration }) => total + duration * 1000,\n                            0\n                        ) - 1000,\n            })),\n        [userSteps.length]\n    );\n\n    // Store whether the timer is running in state:\n    const [isRunning, setIsRunning] = useState(false);\n\n    // Store both current and previous tick timestamps so we can\n    // compute the difference between them:\n    const [currentTick, setCurrentTick] = useState(0);\n    const previousTick = usePrevious(currentTick);\n\n    // Store total elapsed time in state:\n    const [elapsed, setElapsed] = useState(0);\n\n    // Compute the total time needed to complete this timer:\n    const totalTime = useMemo(\n        () => sum(valuesForKey(userSteps, \"duration\")) * 1000,\n        [userSteps.length]\n    );\n\n    // Compute the remaining time:\n    const remaining = useMemo(() => Math.max(totalTime - elapsed, 0), [\n        elapsed,\n    ]);\n\n    // // Determine whether the timer is complete:\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // // Compute the current step's index:\n    const currentStepIndex = useMemo(() => {\n        // find the index of the first step that we find of which we have not yet\n        // passed the start moment:\n        const index = steps.findIndex(({ start }) => elapsed < start);\n\n        // If found, the current step is the step before the one we found.\n        // If not found, we're on the last step.\n        return (index === -1 ? steps.length : index) - 1;\n    }, [elapsed]);\n\n    // // Compute how much time is remaining in the current step\n    const currentStepRemaining = useMemo(() => {\n        // Get the sum of durations of all previous steps (excluding current):\n        const totalPreviousSteps = sum(\n            valuesForKey(steps.slice(0, currentStepIndex), \"duration\")\n        );\n        // Compute the progress within the current step:\n        const progressCurrentStep = elapsed - totalPreviousSteps;\n\n        // Subtract the progress within this step from the total duration:\n        return steps[currentStepIndex].duration - progressCurrentStep;\n    }, [currentStepIndex, elapsed]);\n\n    // Every tick, update the current tick in state:\n    const tick = () => setCurrentTick(Date.now());\n\n    // Tick every 100 millisecons when timer is running:\n    useInterval(tick, isRunning && !isComplete ? 100 : null);\n\n    // Update the total elapsed time by adding the difference\n    // between the current and the previous tick to the previous total:\n    useEffect(() => {\n        // Don't update if we're not running:\n        if (!isRunning) return;\n\n        // Don't update if the previous tick was 0:\n        if (!previousTick || previousTick === 0) return;\n\n        setElapsed((elapsed) => elapsed + (currentTick - previousTick));\n    }, [currentTick]);\n\n    // Expose a method to reset the timer:\n    const reset = useCallback(() => {\n        setIsRunning(false);\n        setElapsed(0);\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to start the timer:\n    const start = useCallback(() => {\n        setCurrentTick(Date.now());\n        setIsRunning(true);\n    }, []);\n\n    // Expose a method to stop (pause) the timer:\n    const stop = useCallback(() => {\n        setIsRunning(false);\n        // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to toggle the timer:\n    const toggle = useCallback(() => {\n        if (isRunning) return stop();\n        return start();\n    }, [isRunning]);\n\n    return {\n        currentStepIndex,\n        currentStepRemaining,\n        elapsed,\n        isComplete,\n        isRunning,\n        remaining,\n        reset,\n        start,\n        stop,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}