{"ast":null,"code":"import { useState, useEffect, useMemo } from \"react\";\nimport { useInterval } from \"./use-interval\";\nexport const useTimer = options => {\n  const {\n    steps\n  } = options; // Initialize timer:\n\n  const totalTime = useMemo(() => steps.reduce((total, step) => total + step.duration * 1000, 0), [steps.length]);\n  const {\n    0: elapsed,\n    1: setElapsed\n  } = useState(0);\n  const {\n    0: isRunning,\n    1: setIsRunning\n  } = useState(false);\n  const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n  const isComplete = useMemo(() => remaining === 0, [remaining]); // const [isComplete, setIsComplete] = useState(false);\n  // const [remaining, setRemaining] = useState(totalTime);\n  // Run the timer:\n\n  const tick = () => setElapsed(elapsed => elapsed += 100);\n\n  useInterval(tick, isRunning && !isComplete ? 100 : null); // Update the remaining time:\n  // useEffect(() => {\n  //     remaining > 0 && setRemaining(totalTime - elapsed);\n  // }, [elapsed]);\n  // Determine the current step:\n\n  useEffect(() => {// Begin looping through each step, adding up the durations.\n    // Once we found a step where the elapsed time is more than the\n    // sum of all previous durations\n  }, [elapsed]); // Determine if the timer is complete:\n  // useEffect(() => {\n  //     if (remaining === 0) {\n  //         setIsComplete(true);\n  //         setIsRunning(false);\n  //     }\n  // }, [remaining]);\n  // Manipulate the timer:\n\n  const pause = () => setIsRunning(false);\n\n  const reset = () => {\n    setElapsed(0);\n    setIsRunning(false);\n  };\n\n  const start = () => setIsRunning(true);\n\n  const toggle = () => setIsRunning(isRunning => !isRunning);\n\n  return {\n    elapsed,\n    isComplete,\n    isRunning,\n    pause,\n    remaining,\n    reset,\n    start,\n    toggle\n  };\n};","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useState","useEffect","useMemo","useInterval","useTimer","options","steps","totalTime","reduce","total","step","duration","length","elapsed","setElapsed","isRunning","setIsRunning","remaining","isComplete","tick","pause","reset","start","toggle"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,OAA9B,QAA6C,OAA7C;AAEA,SAASC,WAAT,QAA4B,gBAA5B;AAWA,OAAO,MAAMC,QAAQ,GAAIC,OAAD,IAAsB;AAC1C,QAAM;AAAEC,IAAAA;AAAF,MAAYD,OAAlB,CAD0C,CAG1C;;AACA,QAAME,SAAS,GAAGL,OAAO,CACrB,MAAMI,KAAK,CAACE,MAAN,CAAa,CAACC,KAAD,EAAQC,IAAR,KAAiBD,KAAK,GAAGC,IAAI,CAACC,QAAL,GAAgB,IAAtD,EAA4D,CAA5D,CADe,EAErB,CAACL,KAAK,CAACM,MAAP,CAFqB,CAAzB;AAIA,QAAM;AAAA,OAACC,OAAD;AAAA,OAAUC;AAAV,MAAwBd,QAAQ,CAAC,CAAD,CAAtC;AACA,QAAM;AAAA,OAACe,SAAD;AAAA,OAAYC;AAAZ,MAA4BhB,QAAQ,CAAC,KAAD,CAA1C;AACA,QAAMiB,SAAS,GAAGf,OAAO,CAAC,MAAMK,SAAS,GAAGM,OAAnB,EAA4B,CAACA,OAAD,CAA5B,CAAzB;AACA,QAAMK,UAAU,GAAGhB,OAAO,CAAC,MAAMe,SAAS,KAAK,CAArB,EAAwB,CAACA,SAAD,CAAxB,CAA1B,CAX0C,CAa1C;AACA;AAEA;;AACA,QAAME,IAAI,GAAG,MAAML,UAAU,CAAED,OAAD,IAAcA,OAAO,IAAI,GAA1B,CAA7B;;AACAV,EAAAA,WAAW,CAACgB,IAAD,EAAOJ,SAAS,IAAI,CAACG,UAAd,GAA2B,GAA3B,GAAiC,IAAxC,CAAX,CAlB0C,CAoB1C;AACA;AACA;AACA;AAEA;;AACAjB,EAAAA,SAAS,CAAC,MAAM,CACZ;AACA;AACA;AACH,GAJQ,EAIN,CAACY,OAAD,CAJM,CAAT,CA1B0C,CAgC1C;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,QAAMO,KAAK,GAAG,MAAMJ,YAAY,CAAC,KAAD,CAAhC;;AACA,QAAMK,KAAK,GAAG,MAAM;AAChBP,IAAAA,UAAU,CAAC,CAAD,CAAV;AACAE,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACH,GAHD;;AAIA,QAAMM,KAAK,GAAG,MAAMN,YAAY,CAAC,IAAD,CAAhC;;AACA,QAAMO,MAAM,GAAG,MAAMP,YAAY,CAAED,SAAD,IAAe,CAACA,SAAjB,CAAjC;;AAEA,SAAO;AACHF,IAAAA,OADG;AAEHK,IAAAA,UAFG;AAGHH,IAAAA,SAHG;AAIHK,IAAAA,KAJG;AAKHH,IAAAA,SALG;AAMHI,IAAAA,KANG;AAOHC,IAAAA,KAPG;AAQHC,IAAAA;AARG,GAAP;AAUH,CA3DM","sourcesContent":["import { useState, useEffect, useMemo } from \"react\";\n\nimport { useInterval } from \"./use-interval\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\ntype Options = {\n    steps: Step[];\n};\n\nexport const useTimer = (options: Options) => {\n    const { steps } = options;\n\n    // Initialize timer:\n    const totalTime = useMemo(\n        () => steps.reduce((total, step) => total + step.duration * 1000, 0),\n        [steps.length]\n    );\n    const [elapsed, setElapsed] = useState(0);\n    const [isRunning, setIsRunning] = useState(false);\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // const [isComplete, setIsComplete] = useState(false);\n    // const [remaining, setRemaining] = useState(totalTime);\n\n    // Run the timer:\n    const tick = () => setElapsed((elapsed) => (elapsed += 100));\n    useInterval(tick, isRunning && !isComplete ? 100 : null);\n\n    // Update the remaining time:\n    // useEffect(() => {\n    //     remaining > 0 && setRemaining(totalTime - elapsed);\n    // }, [elapsed]);\n\n    // Determine the current step:\n    useEffect(() => {\n        // Begin looping through each step, adding up the durations.\n        // Once we found a step where the elapsed time is more than the\n        // sum of all previous durations\n    }, [elapsed]);\n\n    // Determine if the timer is complete:\n    // useEffect(() => {\n    //     if (remaining === 0) {\n    //         setIsComplete(true);\n    //         setIsRunning(false);\n    //     }\n    // }, [remaining]);\n\n    // Manipulate the timer:\n    const pause = () => setIsRunning(false);\n    const reset = () => {\n        setElapsed(0);\n        setIsRunning(false);\n    };\n    const start = () => setIsRunning(true);\n    const toggle = () => setIsRunning((isRunning) => !isRunning);\n\n    return {\n        elapsed,\n        isComplete,\n        isRunning,\n        pause,\n        remaining,\n        reset,\n        start,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}