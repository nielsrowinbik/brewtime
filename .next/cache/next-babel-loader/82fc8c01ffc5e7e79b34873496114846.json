{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState, useMemo, useEffect } from \"react\";\nimport { useInterval } from \"./use-interval\";\n// Yeah turns out this method is awful. Rewrite to something\n// like this: https://stackoverflow.com/a/57981688\nvar STEPSIZE = 100;\nexport var useTimer = function useTimer(userSteps) {\n  _s();\n\n  var _useState = useState(0),\n      startTime = _useState[0],\n      setStartTime = _useState[1];\n\n  var _useState2 = useState(0),\n      overallTime = _useState2[0],\n      setOverallTime = _useState2[1];\n\n  var _useState3 = useState(false),\n      isRunning = _useState3[0],\n      setIsRunning = _useState3[1];\n\n  var _useState4 = useState(Date.now()),\n      lastTick = _useState4[0],\n      setLastTick = _useState4[1];\n\n  var timeElapsedSinceLastStart = useMemo(function () {\n    return Date.now() - startTime;\n  }, [startTime, lastTick]);\n  useEffect(function () {\n    if (isRunning === false) {\n      setOverallTime(function (overallTime) {\n        return overallTime + timeElapsedSinceLastStart;\n      });\n    }\n  }, [isRunning]);\n  var start = useCallback(function () {\n    setIsRunning(true);\n    setStartTime(Date.now());\n  }, []);\n  var stop = useCallback(function () {\n    setIsRunning(false);\n  }, []);\n  var reset = useCallback(function () {\n    setIsRunning(false);\n    setStartTime(0);\n    setOverallTime(0);\n  }, []); // const [elapsed, setElapsed] = useState(0);\n\n  var tick = function tick() {\n    return setLastTick(Date.now());\n  };\n\n  useInterval(tick, isRunning ? STEPSIZE : null); // // Add a \"start\" field to every step that was passed in so we\n  // // can determine which step is the current:\n  // const steps = useMemo(\n  //     () =>\n  //         userSteps.map((step, i) => ({\n  //             // We copy the original step as not to lose any nformation.\n  //             ...step,\n  //             // We convert step duration, which is configured in seconds,\n  //             // to milliseconds here. This overwrites the original duration\n  //             // value!\n  //             duration: step.duration * 1000,\n  //             // The start is determined by the sum of all durations of\n  //             // the previous steps. Once these durations have passed,\n  //             // the current step is active. Finally, subtract 1000 milliseconds\n  //             // to always start a round \"early\".\n  //             start:\n  //                 userSteps\n  //                     .slice(0, i)\n  //                     .reduce(\n  //                         (total, { duration }) => total + duration * 1000,\n  //                         0\n  //                     ) - 1000,\n  //         })),\n  //     [userSteps.length]\n  // );\n  // // Compute the total time, so we can determine whether the timer is done:\n  // const totalTime = useMemo(\n  //     () =>\n  //         userSteps.reduce(\n  //             (total, { duration }) => total + duration * 1000,\n  //             0\n  //         ),\n  //     [userSteps.length]\n  // );\n  // // Keep the elapsed milliseconds in state:\n  // const [elapsed, setElapsed] = useState(0);\n  // // Keep whether the timer is running in state:\n  // const [isRunning, setIsRunning] = useState(false);\n  // // Calculate the total time remaining:\n  // const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n  // // Determine whether the timer is complete:\n  // const isComplete = useMemo(() => remaining === 0, [remaining]);\n  // // Compute the current step's index. This index is equal to the\n  // // index of the first step that we find of which we have not yet\n  // // passed the start moment, minus one.\n  // const currentStepIndex = useMemo(\n  //     () => steps.findIndex(({ start }) => elapsed < start) - 1,\n  //     [elapsed]\n  // );\n  // // Compute the actual current step:\n  // const currentStep = useMemo(() => steps[currentStepIndex], [\n  //     currentStepIndex,\n  // ]);\n  // // Compute how much time is remaining in the current step\n  // const currentStepRemaining = useMemo(\n  //     () => steps[currentStepIndex].duration,\n  //     [currentStepIndex, elapsed]\n  // );\n  // // Run the timer:\n  // const tick = () => setElapsed((elapsed) => (elapsed += STEPSIZE));\n  // useInterval(tick, isRunning && !isComplete ? STEPSIZE : null);\n  // Expose some helper methods to manipulate the timer:\n  // const pause = useCallback(() => setIsRunning(false), []);\n  // const reset = useCallback(() => {\n  //     setElapsed(0);\n  //     setIsRunning(false);\n  // }, []);\n  // const start = useCallback(() => setIsRunning(true), []);\n  // const toggle = useCallback(\n  //     () => setIsRunning((isRunning) => !isRunning),\n  //     []\n  // );\n\n  return {\n    start: start,\n    stop: stop,\n    reset: reset,\n    timeElapsedSinceLastStart: timeElapsedSinceLastStart,\n    startTime: startTime\n  };\n};\n\n_s(useTimer, \"vVbh5cBEgMwodG0XuC5lG/AxDjU=\", false, function () {\n  return [useInterval];\n});","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useEffect","useInterval","STEPSIZE","useTimer","userSteps","startTime","setStartTime","overallTime","setOverallTime","isRunning","setIsRunning","Date","now","lastTick","setLastTick","timeElapsedSinceLastStart","start","stop","reset","tick"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,EAAgCC,OAAhC,EAAyCC,SAAzC,QAA0D,OAA1D;AAEA,SAASC,WAAT,QAA4B,gBAA5B;AAOA;AACA;AAEA,IAAMC,QAAQ,GAAG,GAAjB;AAEA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,SAAD,EAAuB;AAAA;;AAAA,kBACTN,QAAQ,CAAC,CAAD,CADC;AAAA,MACpCO,SADoC;AAAA,MACzBC,YADyB;;AAAA,mBAELR,QAAQ,CAAC,CAAD,CAFH;AAAA,MAEpCS,WAFoC;AAAA,MAEvBC,cAFuB;;AAAA,mBAGTV,QAAQ,CAAC,KAAD,CAHC;AAAA,MAGpCW,SAHoC;AAAA,MAGzBC,YAHyB;;AAAA,mBAIXZ,QAAQ,CAACa,IAAI,CAACC,GAAL,EAAD,CAJG;AAAA,MAIpCC,QAJoC;AAAA,MAI1BC,WAJ0B;;AAM3C,MAAMC,yBAAyB,GAAGhB,OAAO,CAAC;AAAA,WAAMY,IAAI,CAACC,GAAL,KAAaP,SAAnB;AAAA,GAAD,EAA+B,CACpEA,SADoE,EAEpEQ,QAFoE,CAA/B,CAAzC;AAKAb,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAIS,SAAS,KAAK,KAAlB,EAAyB;AACrBD,MAAAA,cAAc,CACV,UAACD,WAAD;AAAA,eAAiBA,WAAW,GAAGQ,yBAA/B;AAAA,OADU,CAAd;AAGH;AACJ,GANQ,EAMN,CAACN,SAAD,CANM,CAAT;AAQA,MAAMO,KAAK,GAAGnB,WAAW,CAAC,YAAM;AAC5Ba,IAAAA,YAAY,CAAC,IAAD,CAAZ;AACAJ,IAAAA,YAAY,CAACK,IAAI,CAACC,GAAL,EAAD,CAAZ;AACH,GAHwB,EAGtB,EAHsB,CAAzB;AAKA,MAAMK,IAAI,GAAGpB,WAAW,CAAC,YAAM;AAC3Ba,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACH,GAFuB,EAErB,EAFqB,CAAxB;AAIA,MAAMQ,KAAK,GAAGrB,WAAW,CAAC,YAAM;AAC5Ba,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACAJ,IAAAA,YAAY,CAAC,CAAD,CAAZ;AACAE,IAAAA,cAAc,CAAC,CAAD,CAAd;AACH,GAJwB,EAItB,EAJsB,CAAzB,CA5B2C,CAkC3C;;AACA,MAAMW,IAAI,GAAG,SAAPA,IAAO;AAAA,WAAML,WAAW,CAACH,IAAI,CAACC,GAAL,EAAD,CAAjB;AAAA,GAAb;;AACAX,EAAAA,WAAW,CAACkB,IAAD,EAAOV,SAAS,GAAGP,QAAH,GAAc,IAA9B,CAAX,CApC2C,CAsC3C;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAO;AACHc,IAAAA,KAAK,EAALA,KADG;AAEHC,IAAAA,IAAI,EAAJA,IAFG;AAGHC,IAAAA,KAAK,EAALA,KAHG;AAIHH,IAAAA,yBAAyB,EAAzBA,yBAJG;AAKHV,IAAAA,SAAS,EAATA;AALG,GAAP;AAOH,CAlIM;;GAAMF,Q;UAoCTF,W","sourcesContent":["import { useCallback, useState, useMemo, useEffect } from \"react\";\n\nimport { useInterval } from \"./use-interval\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\n// Yeah turns out this method is awful. Rewrite to something\n// like this: https://stackoverflow.com/a/57981688\n\nconst STEPSIZE = 100;\n\nexport const useTimer = (userSteps: Step[]) => {\n    const [startTime, setStartTime] = useState(0);\n    const [overallTime, setOverallTime] = useState(0);\n    const [isRunning, setIsRunning] = useState(false);\n    const [lastTick, setLastTick] = useState(Date.now());\n\n    const timeElapsedSinceLastStart = useMemo(() => Date.now() - startTime, [\n        startTime,\n        lastTick,\n    ]);\n\n    useEffect(() => {\n        if (isRunning === false) {\n            setOverallTime(\n                (overallTime) => overallTime + timeElapsedSinceLastStart\n            );\n        }\n    }, [isRunning]);\n\n    const start = useCallback(() => {\n        setIsRunning(true);\n        setStartTime(Date.now());\n    }, []);\n\n    const stop = useCallback(() => {\n        setIsRunning(false);\n    }, []);\n\n    const reset = useCallback(() => {\n        setIsRunning(false);\n        setStartTime(0);\n        setOverallTime(0);\n    }, []);\n\n    // const [elapsed, setElapsed] = useState(0);\n    const tick = () => setLastTick(Date.now());\n    useInterval(tick, isRunning ? STEPSIZE : null);\n\n    // // Add a \"start\" field to every step that was passed in so we\n    // // can determine which step is the current:\n    // const steps = useMemo(\n    //     () =>\n    //         userSteps.map((step, i) => ({\n    //             // We copy the original step as not to lose any nformation.\n    //             ...step,\n\n    //             // We convert step duration, which is configured in seconds,\n    //             // to milliseconds here. This overwrites the original duration\n    //             // value!\n    //             duration: step.duration * 1000,\n\n    //             // The start is determined by the sum of all durations of\n    //             // the previous steps. Once these durations have passed,\n    //             // the current step is active. Finally, subtract 1000 milliseconds\n    //             // to always start a round \"early\".\n    //             start:\n    //                 userSteps\n    //                     .slice(0, i)\n    //                     .reduce(\n    //                         (total, { duration }) => total + duration * 1000,\n    //                         0\n    //                     ) - 1000,\n    //         })),\n    //     [userSteps.length]\n    // );\n\n    // // Compute the total time, so we can determine whether the timer is done:\n    // const totalTime = useMemo(\n    //     () =>\n    //         userSteps.reduce(\n    //             (total, { duration }) => total + duration * 1000,\n    //             0\n    //         ),\n    //     [userSteps.length]\n    // );\n\n    // // Keep the elapsed milliseconds in state:\n    // const [elapsed, setElapsed] = useState(0);\n\n    // // Keep whether the timer is running in state:\n    // const [isRunning, setIsRunning] = useState(false);\n\n    // // Calculate the total time remaining:\n    // const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n\n    // // Determine whether the timer is complete:\n    // const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // // Compute the current step's index. This index is equal to the\n    // // index of the first step that we find of which we have not yet\n    // // passed the start moment, minus one.\n    // const currentStepIndex = useMemo(\n    //     () => steps.findIndex(({ start }) => elapsed < start) - 1,\n    //     [elapsed]\n    // );\n\n    // // Compute the actual current step:\n    // const currentStep = useMemo(() => steps[currentStepIndex], [\n    //     currentStepIndex,\n    // ]);\n\n    // // Compute how much time is remaining in the current step\n    // const currentStepRemaining = useMemo(\n    //     () => steps[currentStepIndex].duration,\n    //     [currentStepIndex, elapsed]\n    // );\n\n    // // Run the timer:\n    // const tick = () => setElapsed((elapsed) => (elapsed += STEPSIZE));\n    // useInterval(tick, isRunning && !isComplete ? STEPSIZE : null);\n\n    // Expose some helper methods to manipulate the timer:\n    // const pause = useCallback(() => setIsRunning(false), []);\n    // const reset = useCallback(() => {\n    //     setElapsed(0);\n    //     setIsRunning(false);\n    // }, []);\n    // const start = useCallback(() => setIsRunning(true), []);\n    // const toggle = useCallback(\n    //     () => setIsRunning((isRunning) => !isRunning),\n    //     []\n    // );\n\n    return {\n        start,\n        stop,\n        reset,\n        timeElapsedSinceLastStart,\n        startTime,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}