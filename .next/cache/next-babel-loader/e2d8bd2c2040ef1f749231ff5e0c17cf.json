{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect, useMemo } from \"react\";\nimport { useInterval } from \"./use-interval\";\nexport var useTimer = function useTimer(options) {\n  _s();\n\n  var steps = options.steps; // Initialize timer:\n\n  var totalTime = useMemo(function () {\n    return steps.reduce(function (total, step) {\n      return total + step.duration * 1000;\n    }, 0);\n  }, [steps.length]);\n\n  var _useState = useState(0),\n      elapsed = _useState[0],\n      setElapsed = _useState[1];\n\n  var _useState2 = useState(false),\n      isRunning = _useState2[0],\n      setIsRunning = _useState2[1];\n\n  var remaining = useMemo(function () {\n    return totalTime - elapsed;\n  }, [elapsed]);\n  var isComplete = useMemo(function () {\n    return remaining === 0;\n  }, [remaining]); // const [isComplete, setIsComplete] = useState(false);\n  // const [remaining, setRemaining] = useState(totalTime);\n  // Run the timer:\n\n  var tick = function tick() {\n    return setElapsed(function (elapsed) {\n      return elapsed += 100;\n    });\n  };\n\n  useInterval(tick, isRunning && !isComplete ? 100 : null); // Update the remaining time:\n  // useEffect(() => {\n  //     remaining > 0 && setRemaining(totalTime - elapsed);\n  // }, [elapsed]);\n  // Determine the current step:\n\n  useEffect(function () {// Begin looping through each step, adding up the durations.\n    // Once we found a step where the elapsed time is more than the\n    // sum of all previous durations\n  }, [elapsed]); // Determine if the timer is complete:\n  // useEffect(() => {\n  //     if (remaining === 0) {\n  //         setIsComplete(true);\n  //         setIsRunning(false);\n  //     }\n  // }, [remaining]);\n  // Manipulate the timer:\n\n  var pause = function pause() {\n    return setIsRunning(false);\n  };\n\n  var reset = function reset() {\n    setElapsed(0);\n    setIsRunning(false);\n  };\n\n  var start = function start() {\n    return setIsRunning(true);\n  };\n\n  var toggle = function toggle() {\n    return setIsRunning(function (isRunning) {\n      return !isRunning;\n    });\n  };\n\n  return {\n    elapsed: elapsed,\n    isComplete: isComplete,\n    isRunning: isRunning,\n    pause: pause,\n    remaining: remaining,\n    reset: reset,\n    start: start,\n    toggle: toggle\n  };\n};\n\n_s(useTimer, \"xjPb7g/HYiHUvp4YKghXSBt4IBo=\", false, function () {\n  return [useInterval];\n});","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useState","useEffect","useMemo","useInterval","useTimer","options","steps","totalTime","reduce","total","step","duration","length","elapsed","setElapsed","isRunning","setIsRunning","remaining","isComplete","tick","pause","reset","start","toggle"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,OAA9B,QAA6C,OAA7C;AAEA,SAASC,WAAT,QAA4B,gBAA5B;AAWA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,OAAD,EAAsB;AAAA;;AAAA,MAClCC,KADkC,GACxBD,OADwB,CAClCC,KADkC,EAG1C;;AACA,MAAMC,SAAS,GAAGL,OAAO,CACrB;AAAA,WAAMI,KAAK,CAACE,MAAN,CAAa,UAACC,KAAD,EAAQC,IAAR;AAAA,aAAiBD,KAAK,GAAGC,IAAI,CAACC,QAAL,GAAgB,IAAzC;AAAA,KAAb,EAA4D,CAA5D,CAAN;AAAA,GADqB,EAErB,CAACL,KAAK,CAACM,MAAP,CAFqB,CAAzB;;AAJ0C,kBAQZZ,QAAQ,CAAC,CAAD,CARI;AAAA,MAQnCa,OARmC;AAAA,MAQ1BC,UAR0B;;AAAA,mBASRd,QAAQ,CAAC,KAAD,CATA;AAAA,MASnCe,SATmC;AAAA,MASxBC,YATwB;;AAU1C,MAAMC,SAAS,GAAGf,OAAO,CAAC;AAAA,WAAMK,SAAS,GAAGM,OAAlB;AAAA,GAAD,EAA4B,CAACA,OAAD,CAA5B,CAAzB;AACA,MAAMK,UAAU,GAAGhB,OAAO,CAAC;AAAA,WAAMe,SAAS,KAAK,CAApB;AAAA,GAAD,EAAwB,CAACA,SAAD,CAAxB,CAA1B,CAX0C,CAa1C;AACA;AAEA;;AACA,MAAME,IAAI,GAAG,SAAPA,IAAO;AAAA,WAAML,UAAU,CAAC,UAACD,OAAD;AAAA,aAAcA,OAAO,IAAI,GAAzB;AAAA,KAAD,CAAhB;AAAA,GAAb;;AACAV,EAAAA,WAAW,CAACgB,IAAD,EAAOJ,SAAS,IAAI,CAACG,UAAd,GAA2B,GAA3B,GAAiC,IAAxC,CAAX,CAlB0C,CAoB1C;AACA;AACA;AACA;AAEA;;AACAjB,EAAAA,SAAS,CAAC,YAAM,CACZ;AACA;AACA;AACH,GAJQ,EAIN,CAACY,OAAD,CAJM,CAAT,CA1B0C,CAgC1C;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,MAAMO,KAAK,GAAG,SAARA,KAAQ;AAAA,WAAMJ,YAAY,CAAC,KAAD,CAAlB;AAAA,GAAd;;AACA,MAAMK,KAAK,GAAG,SAARA,KAAQ,GAAM;AAChBP,IAAAA,UAAU,CAAC,CAAD,CAAV;AACAE,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACH,GAHD;;AAIA,MAAMM,KAAK,GAAG,SAARA,KAAQ;AAAA,WAAMN,YAAY,CAAC,IAAD,CAAlB;AAAA,GAAd;;AACA,MAAMO,MAAM,GAAG,SAATA,MAAS;AAAA,WAAMP,YAAY,CAAC,UAACD,SAAD;AAAA,aAAe,CAACA,SAAhB;AAAA,KAAD,CAAlB;AAAA,GAAf;;AAEA,SAAO;AACHF,IAAAA,OAAO,EAAPA,OADG;AAEHK,IAAAA,UAAU,EAAVA,UAFG;AAGHH,IAAAA,SAAS,EAATA,SAHG;AAIHK,IAAAA,KAAK,EAALA,KAJG;AAKHH,IAAAA,SAAS,EAATA,SALG;AAMHI,IAAAA,KAAK,EAALA,KANG;AAOHC,IAAAA,KAAK,EAALA,KAPG;AAQHC,IAAAA,MAAM,EAANA;AARG,GAAP;AAUH,CA3DM;;GAAMnB,Q;UAkBTD,W","sourcesContent":["import { useState, useEffect, useMemo } from \"react\";\n\nimport { useInterval } from \"./use-interval\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\ntype Options = {\n    steps: Step[];\n};\n\nexport const useTimer = (options: Options) => {\n    const { steps } = options;\n\n    // Initialize timer:\n    const totalTime = useMemo(\n        () => steps.reduce((total, step) => total + step.duration * 1000, 0),\n        [steps.length]\n    );\n    const [elapsed, setElapsed] = useState(0);\n    const [isRunning, setIsRunning] = useState(false);\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // const [isComplete, setIsComplete] = useState(false);\n    // const [remaining, setRemaining] = useState(totalTime);\n\n    // Run the timer:\n    const tick = () => setElapsed((elapsed) => (elapsed += 100));\n    useInterval(tick, isRunning && !isComplete ? 100 : null);\n\n    // Update the remaining time:\n    // useEffect(() => {\n    //     remaining > 0 && setRemaining(totalTime - elapsed);\n    // }, [elapsed]);\n\n    // Determine the current step:\n    useEffect(() => {\n        // Begin looping through each step, adding up the durations.\n        // Once we found a step where the elapsed time is more than the\n        // sum of all previous durations\n    }, [elapsed]);\n\n    // Determine if the timer is complete:\n    // useEffect(() => {\n    //     if (remaining === 0) {\n    //         setIsComplete(true);\n    //         setIsRunning(false);\n    //     }\n    // }, [remaining]);\n\n    // Manipulate the timer:\n    const pause = () => setIsRunning(false);\n    const reset = () => {\n        setElapsed(0);\n        setIsRunning(false);\n    };\n    const start = () => setIsRunning(true);\n    const toggle = () => setIsRunning((isRunning) => !isRunning);\n\n    return {\n        elapsed,\n        isComplete,\n        isRunning,\n        pause,\n        remaining,\n        reset,\n        start,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}