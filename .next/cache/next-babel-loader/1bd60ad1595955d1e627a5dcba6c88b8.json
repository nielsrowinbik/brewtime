{"ast":null,"code":"import { useCallback, useState, useMemo, useEffect } from \"react\";\nimport { usePrevious } from \"react-delta\";\nimport { useInterval } from \"../hooks/use-interval\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\nexport const useTimer = userSteps => {\n  // Store whether the timer is running in state:\n  const {\n    0: isRunning,\n    1: setIsRunning\n  } = useState(false); // Store both current and previous tick timestamps so we can\n  // compute the difference between them:\n\n  const {\n    0: currentTick,\n    1: setCurrentTick\n  } = useState(0);\n  const previousTick = usePrevious(currentTick); // const delta = useDelta(currentTick);\n  // Store total elapsed time in state:\n\n  const {\n    0: elapsed,\n    1: setElapsed\n  } = useState(0); // Compute the total time needed to complete this timer:\n\n  const totalTime = useMemo(() => sum(valuesForKey(userSteps, \"duration\")) * 1000, [userSteps.length]); // Compute the remaining time:\n\n  const remaining = useMemo(() => totalTime - elapsed, [elapsed]); // // Determine whether the timer is complete:\n\n  const isComplete = useMemo(() => remaining === 0, [remaining]); // Every tick, update the current tick in state:\n\n  const tick = () => setCurrentTick(Date.now()); // Tick every 100 millisecons when timer is running:\n\n\n  useInterval(tick, isRunning ? 100 : null); // Update the total elapsed time by adding the difference\n  // between the current and the previous tick to the previous total:\n\n  useEffect(() => {\n    // Don't update if we're not running:\n    if (!isRunning) return; // Don't update if the previous tick was 0:\n\n    if (!previousTick || previousTick === 0) return;\n    setElapsed(elapsed => elapsed + (currentTick - previousTick));\n  }, [currentTick]); // Expose a method to reset the timer:\n\n  const reset = useCallback(() => {\n    setIsRunning(false);\n    setElapsed(0);\n    setCurrentTick(0);\n  }, []); // Expose a method to start the timer:\n\n  const start = useCallback(() => {\n    setCurrentTick(Date.now());\n    setIsRunning(true);\n  }, []); // Expose a method to stop (pause) the timer:\n\n  const stop = useCallback(() => {\n    setIsRunning(false); // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n\n    setCurrentTick(0);\n  }, []); // Expose a method to toggle the timer:\n\n  const toggle = useCallback(() => {\n    if (isRunning) return stop();\n    return start();\n  }, [isRunning]); // // Add a \"start\" field to every step that was passed in so we\n  // // can determine which step is the current:\n  // const steps = useMemo(\n  //     () =>\n  //         userSteps.map((step, i) => ({\n  //             // We copy the original step as not to lose any nformation.\n  //             ...step,\n  //             // We convert step duration, which is configured in seconds,\n  //             // to milliseconds here. This overwrites the original duration\n  //             // value!\n  //             duration: step.duration * 1000,\n  //             // The start is determined by the sum of all durations of\n  //             // the previous steps. Once these durations have passed,\n  //             // the current step is active. Finally, subtract 1000 milliseconds\n  //             // to always start a round \"early\".\n  //             start:\n  //                 userSteps\n  //                     .slice(0, i)\n  //                     .reduce(\n  //                         (total, { duration }) => total + duration * 1000,\n  //                         0\n  //                     ) - 1000,\n  //         })),\n  //     [userSteps.length]\n  // );\n  // // Compute the total time, so we can determine whether the timer is done:\n  // const totalTime = useMemo(\n  //     () =>\n  //         userSteps.reduce(\n  //             (total, { duration }) => total + duration * 1000,\n  //             0\n  //         ),\n  //     [userSteps.length]\n  // );\n  // // Determine whether the timer is complete:\n  // const isComplete = useMemo(() => remaining === 0, [remaining]);\n  // // Compute the current step's index. This index is equal to the\n  // // index of the first step that we find of which we have not yet\n  // // passed the start moment, minus one.\n  // const currentStepIndex = useMemo(\n  //     () => steps.findIndex(({ start }) => elapsed < start) - 1,\n  //     [elapsed]\n  // );\n  // // Compute the actual current step:\n  // const currentStep = useMemo(() => steps[currentStepIndex], [\n  //     currentStepIndex,\n  // ]);\n  // // Compute how much time is remaining in the current step\n  // const currentStepRemaining = useMemo(\n  //     () => steps[currentStepIndex].duration,\n  //     [currentStepIndex, elapsed]\n  // );\n  // // Run the timer:\n  // const tick = () => setElapsed((elapsed) => (elapsed += STEPSIZE));\n  // useInterval(tick, isRunning && !isComplete ? STEPSIZE : null);\n  // Expose some helper methods to manipulate the timer:\n  // const pause = useCallback(() => setIsRunning(false), []);\n  // const reset = useCallback(() => {\n  //     setElapsed(0);\n  //     setIsRunning(false);\n  // }, []);\n  // const start = useCallback(() => setIsRunning(true), []);\n  // const toggle = useCallback(\n  //     () => setIsRunning((isRunning) => !isRunning),\n  //     []\n  // );\n\n  return {\n    elapsed,\n    isComplete,\n    isRunning,\n    remaining,\n    reset,\n    start,\n    stop,\n    toggle\n  };\n};","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useEffect","usePrevious","useInterval","sum","valuesForKey","useTimer","userSteps","isRunning","setIsRunning","currentTick","setCurrentTick","previousTick","elapsed","setElapsed","totalTime","length","remaining","isComplete","tick","Date","now","reset","start","stop","toggle"],"mappings":"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","sourcesContent":["import { useCallback, useState, useMemo, useEffect } from \"react\";\nimport { useDelta, usePrevious } from \"react-delta\";\n\nimport { useInterval } from \"../hooks/use-interval\";\nimport { sum, valuesForKey } from \"../utils/helpers\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\nexport const useTimer = (userSteps: Step[]) => {\n    // Store whether the timer is running in state:\n    const [isRunning, setIsRunning] = useState(false);\n\n    // Store both current and previous tick timestamps so we can\n    // compute the difference between them:\n    const [currentTick, setCurrentTick] = useState(0);\n    const previousTick = usePrevious(currentTick);\n    // const delta = useDelta(currentTick);\n\n    // Store total elapsed time in state:\n    const [elapsed, setElapsed] = useState(0);\n\n    // Compute the total time needed to complete this timer:\n    const totalTime = useMemo(\n        () => sum(valuesForKey(userSteps, \"duration\")) * 1000,\n        [userSteps.length]\n    );\n\n    // Compute the remaining time:\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n\n    // // Determine whether the timer is complete:\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // Every tick, update the current tick in state:\n    const tick = () => setCurrentTick(Date.now());\n\n    // Tick every 100 millisecons when timer is running:\n    useInterval(tick, isRunning ? 100 : null);\n\n    // Update the total elapsed time by adding the difference\n    // between the current and the previous tick to the previous total:\n    useEffect(() => {\n        // Don't update if we're not running:\n        if (!isRunning) return;\n\n        // Don't update if the previous tick was 0:\n        if (!previousTick || previousTick === 0) return;\n\n        setElapsed((elapsed) => elapsed + (currentTick - previousTick));\n    }, [currentTick]);\n\n    // Expose a method to reset the timer:\n    const reset = useCallback(() => {\n        setIsRunning(false);\n        setElapsed(0);\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to start the timer:\n    const start = useCallback(() => {\n        setCurrentTick(Date.now());\n        setIsRunning(true);\n    }, []);\n\n    // Expose a method to stop (pause) the timer:\n    const stop = useCallback(() => {\n        setIsRunning(false);\n        // FIXME: this fixes pause functionality, but we don't count the time between the last tick and us pausing the timer\n        setCurrentTick(0);\n    }, []);\n\n    // Expose a method to toggle the timer:\n    const toggle = useCallback(() => {\n        if (isRunning) return stop();\n        return start();\n    }, [isRunning]);\n\n    // // Add a \"start\" field to every step that was passed in so we\n    // // can determine which step is the current:\n    // const steps = useMemo(\n    //     () =>\n    //         userSteps.map((step, i) => ({\n    //             // We copy the original step as not to lose any nformation.\n    //             ...step,\n\n    //             // We convert step duration, which is configured in seconds,\n    //             // to milliseconds here. This overwrites the original duration\n    //             // value!\n    //             duration: step.duration * 1000,\n\n    //             // The start is determined by the sum of all durations of\n    //             // the previous steps. Once these durations have passed,\n    //             // the current step is active. Finally, subtract 1000 milliseconds\n    //             // to always start a round \"early\".\n    //             start:\n    //                 userSteps\n    //                     .slice(0, i)\n    //                     .reduce(\n    //                         (total, { duration }) => total + duration * 1000,\n    //                         0\n    //                     ) - 1000,\n    //         })),\n    //     [userSteps.length]\n    // );\n\n    // // Compute the total time, so we can determine whether the timer is done:\n    // const totalTime = useMemo(\n    //     () =>\n    //         userSteps.reduce(\n    //             (total, { duration }) => total + duration * 1000,\n    //             0\n    //         ),\n    //     [userSteps.length]\n    // );\n\n    // // Determine whether the timer is complete:\n    // const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // // Compute the current step's index. This index is equal to the\n    // // index of the first step that we find of which we have not yet\n    // // passed the start moment, minus one.\n    // const currentStepIndex = useMemo(\n    //     () => steps.findIndex(({ start }) => elapsed < start) - 1,\n    //     [elapsed]\n    // );\n\n    // // Compute the actual current step:\n    // const currentStep = useMemo(() => steps[currentStepIndex], [\n    //     currentStepIndex,\n    // ]);\n\n    // // Compute how much time is remaining in the current step\n    // const currentStepRemaining = useMemo(\n    //     () => steps[currentStepIndex].duration,\n    //     [currentStepIndex, elapsed]\n    // );\n\n    // // Run the timer:\n    // const tick = () => setElapsed((elapsed) => (elapsed += STEPSIZE));\n    // useInterval(tick, isRunning && !isComplete ? STEPSIZE : null);\n\n    // Expose some helper methods to manipulate the timer:\n    // const pause = useCallback(() => setIsRunning(false), []);\n    // const reset = useCallback(() => {\n    //     setElapsed(0);\n    //     setIsRunning(false);\n    // }, []);\n    // const start = useCallback(() => setIsRunning(true), []);\n    // const toggle = useCallback(\n    //     () => setIsRunning((isRunning) => !isRunning),\n    //     []\n    // );\n\n    return {\n        elapsed,\n        isComplete,\n        isRunning,\n        remaining,\n        reset,\n        start,\n        stop,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}