{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useCallback, useState, useMemo } from \"react\";\nimport { useInterval } from \"./use-interval\";\nexport var useTimer = function useTimer(userSteps) {\n  _s();\n\n  // Add a \"start\" field to every step that was passed in so we\n  // can determine which step is the current:\n  var steps = useMemo(function () {\n    return userSteps.map(function (step, i) {\n      return _objectSpread(_objectSpread({}, step), {}, {\n        // We convert step duration, which is configured in seconds,\n        // to milliseconds here. This overwrites the original duration\n        // value!\n        duration: step.duration * 1000,\n        // The start is determined by the sum of all durations of\n        // the previous steps. Once these durations have passed,\n        // the current step is active.\n        start: userSteps.slice(0, i).reduce(function (total, _ref) {\n          var duration = _ref.duration;\n          return total + duration * 1000;\n        }, 0)\n      });\n    });\n  }, [userSteps.length]); // Compute the total time, so we can determine whether the timer is done:\n\n  var totalTime = useMemo(function () {\n    return userSteps.reduce(function (total, _ref2) {\n      var duration = _ref2.duration;\n      return total + duration * 1000;\n    }, 0);\n  }, [userSteps.length]); // Keep the elapsed milliseconds in state:\n\n  var _useState = useState(0),\n      elapsed = _useState[0],\n      setElapsed = _useState[1]; // Keep whether the timer is running in state:\n\n\n  var _useState2 = useState(false),\n      isRunning = _useState2[0],\n      setIsRunning = _useState2[1]; // Calculate the total time remaining:\n\n\n  var remaining = useMemo(function () {\n    return totalTime - elapsed;\n  }, [elapsed]); // Determine whether the timer is complete:\n\n  var isComplete = useMemo(function () {\n    return remaining === 0;\n  }, [remaining]); // Compute the current step's index. This index is equal to the\n  // index of the first step that we find of which we have not yet\n  // passed the start moment, minus one.\n\n  var currentStepIndex = useMemo(function () {\n    return steps.findIndex(function (_ref3) {\n      var start = _ref3.start;\n      return elapsed < start;\n    }) - 1;\n  }, [elapsed]); // Run the timer:\n\n  var tick = function tick() {\n    return setElapsed(function (elapsed) {\n      return elapsed += 100;\n    });\n  };\n\n  useInterval(tick, isRunning && !isComplete ? 100 : null); // Expose some helper methods to manipulate the timer:\n\n  var pause = useCallback(function () {\n    return setIsRunning(false);\n  }, []);\n  var reset = useCallback(function () {\n    setElapsed(0);\n    setIsRunning(false);\n  }, []);\n  var start = useCallback(function () {\n    return setIsRunning(true);\n  }, []);\n  var toggle = useCallback(function () {\n    return setIsRunning(function (isRunning) {\n      return !isRunning;\n    });\n  }, []);\n  return {\n    currentStepIndex: currentStepIndex,\n    elapsed: elapsed,\n    isComplete: isComplete,\n    isRunning: isRunning,\n    pause: pause,\n    remaining: remaining,\n    reset: reset,\n    start: start,\n    toggle: toggle\n  };\n};\n\n_s(useTimer, \"iDHXx67Dbat4ZFwmqmalcl83dac=\", false, function () {\n  return [useInterval];\n});","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useInterval","useTimer","userSteps","steps","map","step","i","duration","start","slice","reduce","total","length","totalTime","elapsed","setElapsed","isRunning","setIsRunning","remaining","isComplete","currentStepIndex","findIndex","tick","pause","reset","toggle"],"mappings":"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","sourcesContent":["import { useCallback, useState, useMemo } from \"react\";\n\nimport { useInterval } from \"./use-interval\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\nexport const useTimer = (userSteps: Step[]) => {\n    // Add a \"start\" field to every step that was passed in so we\n    // can determine which step is the current:\n    const steps = useMemo(\n        () =>\n            userSteps.map((step, i) => ({\n                // We copy the original step as not to lose any nformation.\n                ...step,\n\n                // We convert step duration, which is configured in seconds,\n                // to milliseconds here. This overwrites the original duration\n                // value!\n                duration: step.duration * 1000,\n\n                // The start is determined by the sum of all durations of\n                // the previous steps. Once these durations have passed,\n                // the current step is active.\n                start: userSteps\n                    .slice(0, i)\n                    .reduce(\n                        (total, { duration }) => total + duration * 1000,\n                        0\n                    ),\n            })),\n        [userSteps.length]\n    );\n\n    // Compute the total time, so we can determine whether the timer is done:\n    const totalTime = useMemo(\n        () =>\n            userSteps.reduce(\n                (total, { duration }) => total + duration * 1000,\n                0\n            ),\n        [userSteps.length]\n    );\n\n    // Keep the elapsed milliseconds in state:\n    const [elapsed, setElapsed] = useState(0);\n\n    // Keep whether the timer is running in state:\n    const [isRunning, setIsRunning] = useState(false);\n\n    // Calculate the total time remaining:\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n\n    // Determine whether the timer is complete:\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // Compute the current step's index. This index is equal to the\n    // index of the first step that we find of which we have not yet\n    // passed the start moment, minus one.\n    const currentStepIndex = useMemo(\n        () => steps.findIndex(({ start }) => elapsed < start) - 1,\n        [elapsed]\n    );\n\n    // Run the timer:\n    const tick = () => setElapsed((elapsed) => (elapsed += 100));\n    useInterval(tick, isRunning && !isComplete ? 100 : null);\n\n    // Expose some helper methods to manipulate the timer:\n    const pause = useCallback(() => setIsRunning(false), []);\n    const reset = useCallback(() => {\n        setElapsed(0);\n        setIsRunning(false);\n    }, []);\n    const start = useCallback(() => setIsRunning(true), []);\n    const toggle = useCallback(\n        () => setIsRunning((isRunning) => !isRunning),\n        []\n    );\n\n    return {\n        currentStepIndex,\n        elapsed,\n        isComplete,\n        isRunning,\n        pause,\n        remaining,\n        reset,\n        start,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}