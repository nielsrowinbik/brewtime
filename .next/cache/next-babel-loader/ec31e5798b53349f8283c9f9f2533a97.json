{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback, useState, useMemo } from \"react\";\nimport { useInterval } from \"./use-interval\";\nconst STEPSIZE = 100;\nexport const useTimer = userSteps => {\n  // Add a \"start\" field to every step that was passed in so we\n  // can determine which step is the current:\n  const steps = useMemo(() => userSteps.map((step, i) => _objectSpread(_objectSpread({}, step), {}, {\n    // We convert step duration, which is configured in seconds,\n    // to milliseconds here. This overwrites the original duration\n    // value!\n    duration: step.duration * 1000,\n    // The start is determined by the sum of all durations of\n    // the previous steps. Once these durations have passed,\n    // the current step is active. Finally, subtract 1000 milliseconds\n    // to always start a round \"early\".\n    start: userSteps.slice(0, i).reduce((total, {\n      duration\n    }) => total + duration * 1000, 0) - 1000\n  })), [userSteps.length]); // Compute the total time, so we can determine whether the timer is done:\n\n  const totalTime = useMemo(() => userSteps.reduce((total, {\n    duration\n  }) => total + duration * 1000, 0), [userSteps.length]); // Keep the elapsed milliseconds in state:\n\n  const {\n    0: elapsed,\n    1: setElapsed\n  } = useState(0); // Keep whether the timer is running in state:\n\n  const {\n    0: isRunning,\n    1: setIsRunning\n  } = useState(false); // Calculate the total time remaining:\n\n  const remaining = useMemo(() => totalTime - elapsed, [elapsed]); // Determine whether the timer is complete:\n\n  const isComplete = useMemo(() => remaining === 0, [remaining]); // Compute the current step's index. This index is equal to the\n  // index of the first step that we find of which we have not yet\n  // passed the start moment, minus one.\n\n  const currentStepIndex = useMemo(() => steps.findIndex(({\n    start\n  }) => elapsed < start) - 1, [elapsed]); // Compute the actual current step:\n\n  const currentStep = useMemo(() => steps[currentStepIndex], [currentStepIndex]); // Compute how much time is remaining in the current step\n\n  const currentStepRemaining = useMemo(() => steps[currentStepIndex].duration, [currentStepIndex, elapsed]); // Run the timer:\n\n  const tick = () => setElapsed(elapsed => elapsed += STEPSIZE);\n\n  useInterval(tick, isRunning && !isComplete ? STEPSIZE : null); // Expose some helper methods to manipulate the timer:\n\n  const pause = useCallback(() => setIsRunning(false), []);\n  const reset = useCallback(() => {\n    setElapsed(0);\n    setIsRunning(false);\n  }, []);\n  const start = useCallback(() => setIsRunning(true), []);\n  const toggle = useCallback(() => setIsRunning(isRunning => !isRunning), []);\n  return {\n    currentStep,\n    currentStepIndex,\n    currentStepRemaining,\n    elapsed,\n    isComplete,\n    isRunning,\n    pause,\n    remaining,\n    reset,\n    start,\n    toggle\n  };\n};","map":{"version":3,"sources":["/home/niels/dev/nielsrowinbik/brewtime/hooks/use-timer.ts"],"names":["useCallback","useState","useMemo","useInterval","STEPSIZE","useTimer","userSteps","steps","map","step","i","duration","start","slice","reduce","total","length","totalTime","elapsed","setElapsed","isRunning","setIsRunning","remaining","isComplete","currentStepIndex","findIndex","currentStep","currentStepRemaining","tick","pause","reset","toggle"],"mappings":";;;;;;AAAA,SAASA,WAAT,EAAsBC,QAAtB,EAAgCC,OAAhC,QAA+C,OAA/C;AAEA,SAASC,WAAT,QAA4B,gBAA5B;AAOA,MAAMC,QAAQ,GAAG,GAAjB;AAEA,OAAO,MAAMC,QAAQ,GAAIC,SAAD,IAAuB;AAC3C;AACA;AACA,QAAMC,KAAK,GAAGL,OAAO,CACjB,MACII,SAAS,CAACE,GAAV,CAAc,CAACC,IAAD,EAAOC,CAAP,qCAEPD,IAFO;AAIV;AACA;AACA;AACAE,IAAAA,QAAQ,EAAEF,IAAI,CAACE,QAAL,GAAgB,IAPhB;AASV;AACA;AACA;AACA;AACAC,IAAAA,KAAK,EACDN,SAAS,CACJO,KADL,CACW,CADX,EACcH,CADd,EAEKI,MAFL,CAGQ,CAACC,KAAD,EAAQ;AAAEJ,MAAAA;AAAF,KAAR,KAAyBI,KAAK,GAAGJ,QAAQ,GAAG,IAHpD,EAIQ,CAJR,IAKQ;AAnBF,IAAd,CAFa,EAuBjB,CAACL,SAAS,CAACU,MAAX,CAvBiB,CAArB,CAH2C,CA6B3C;;AACA,QAAMC,SAAS,GAAGf,OAAO,CACrB,MACII,SAAS,CAACQ,MAAV,CACI,CAACC,KAAD,EAAQ;AAAEJ,IAAAA;AAAF,GAAR,KAAyBI,KAAK,GAAGJ,QAAQ,GAAG,IADhD,EAEI,CAFJ,CAFiB,EAMrB,CAACL,SAAS,CAACU,MAAX,CANqB,CAAzB,CA9B2C,CAuC3C;;AACA,QAAM;AAAA,OAACE,OAAD;AAAA,OAAUC;AAAV,MAAwBlB,QAAQ,CAAC,CAAD,CAAtC,CAxC2C,CA0C3C;;AACA,QAAM;AAAA,OAACmB,SAAD;AAAA,OAAYC;AAAZ,MAA4BpB,QAAQ,CAAC,KAAD,CAA1C,CA3C2C,CA6C3C;;AACA,QAAMqB,SAAS,GAAGpB,OAAO,CAAC,MAAMe,SAAS,GAAGC,OAAnB,EAA4B,CAACA,OAAD,CAA5B,CAAzB,CA9C2C,CAgD3C;;AACA,QAAMK,UAAU,GAAGrB,OAAO,CAAC,MAAMoB,SAAS,KAAK,CAArB,EAAwB,CAACA,SAAD,CAAxB,CAA1B,CAjD2C,CAmD3C;AACA;AACA;;AACA,QAAME,gBAAgB,GAAGtB,OAAO,CAC5B,MAAMK,KAAK,CAACkB,SAAN,CAAgB,CAAC;AAAEb,IAAAA;AAAF,GAAD,KAAeM,OAAO,GAAGN,KAAzC,IAAkD,CAD5B,EAE5B,CAACM,OAAD,CAF4B,CAAhC,CAtD2C,CA2D3C;;AACA,QAAMQ,WAAW,GAAGxB,OAAO,CAAC,MAAMK,KAAK,CAACiB,gBAAD,CAAZ,EAAgC,CACvDA,gBADuD,CAAhC,CAA3B,CA5D2C,CAgE3C;;AACA,QAAMG,oBAAoB,GAAGzB,OAAO,CAChC,MAAMK,KAAK,CAACiB,gBAAD,CAAL,CAAwBb,QADE,EAEhC,CAACa,gBAAD,EAAmBN,OAAnB,CAFgC,CAApC,CAjE2C,CAsE3C;;AACA,QAAMU,IAAI,GAAG,MAAMT,UAAU,CAAED,OAAD,IAAcA,OAAO,IAAId,QAA1B,CAA7B;;AACAD,EAAAA,WAAW,CAACyB,IAAD,EAAOR,SAAS,IAAI,CAACG,UAAd,GAA2BnB,QAA3B,GAAsC,IAA7C,CAAX,CAxE2C,CA0E3C;;AACA,QAAMyB,KAAK,GAAG7B,WAAW,CAAC,MAAMqB,YAAY,CAAC,KAAD,CAAnB,EAA4B,EAA5B,CAAzB;AACA,QAAMS,KAAK,GAAG9B,WAAW,CAAC,MAAM;AAC5BmB,IAAAA,UAAU,CAAC,CAAD,CAAV;AACAE,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACH,GAHwB,EAGtB,EAHsB,CAAzB;AAIA,QAAMT,KAAK,GAAGZ,WAAW,CAAC,MAAMqB,YAAY,CAAC,IAAD,CAAnB,EAA2B,EAA3B,CAAzB;AACA,QAAMU,MAAM,GAAG/B,WAAW,CACtB,MAAMqB,YAAY,CAAED,SAAD,IAAe,CAACA,SAAjB,CADI,EAEtB,EAFsB,CAA1B;AAKA,SAAO;AACHM,IAAAA,WADG;AAEHF,IAAAA,gBAFG;AAGHG,IAAAA,oBAHG;AAIHT,IAAAA,OAJG;AAKHK,IAAAA,UALG;AAMHH,IAAAA,SANG;AAOHS,IAAAA,KAPG;AAQHP,IAAAA,SARG;AASHQ,IAAAA,KATG;AAUHlB,IAAAA,KAVG;AAWHmB,IAAAA;AAXG,GAAP;AAaH,CAnGM","sourcesContent":["import { useCallback, useState, useMemo } from \"react\";\n\nimport { useInterval } from \"./use-interval\";\n\ntype Step = {\n    description: string;\n    duration: number;\n};\n\nconst STEPSIZE = 100;\n\nexport const useTimer = (userSteps: Step[]) => {\n    // Add a \"start\" field to every step that was passed in so we\n    // can determine which step is the current:\n    const steps = useMemo(\n        () =>\n            userSteps.map((step, i) => ({\n                // We copy the original step as not to lose any nformation.\n                ...step,\n\n                // We convert step duration, which is configured in seconds,\n                // to milliseconds here. This overwrites the original duration\n                // value!\n                duration: step.duration * 1000,\n\n                // The start is determined by the sum of all durations of\n                // the previous steps. Once these durations have passed,\n                // the current step is active. Finally, subtract 1000 milliseconds\n                // to always start a round \"early\".\n                start:\n                    userSteps\n                        .slice(0, i)\n                        .reduce(\n                            (total, { duration }) => total + duration * 1000,\n                            0\n                        ) - 1000,\n            })),\n        [userSteps.length]\n    );\n\n    // Compute the total time, so we can determine whether the timer is done:\n    const totalTime = useMemo(\n        () =>\n            userSteps.reduce(\n                (total, { duration }) => total + duration * 1000,\n                0\n            ),\n        [userSteps.length]\n    );\n\n    // Keep the elapsed milliseconds in state:\n    const [elapsed, setElapsed] = useState(0);\n\n    // Keep whether the timer is running in state:\n    const [isRunning, setIsRunning] = useState(false);\n\n    // Calculate the total time remaining:\n    const remaining = useMemo(() => totalTime - elapsed, [elapsed]);\n\n    // Determine whether the timer is complete:\n    const isComplete = useMemo(() => remaining === 0, [remaining]);\n\n    // Compute the current step's index. This index is equal to the\n    // index of the first step that we find of which we have not yet\n    // passed the start moment, minus one.\n    const currentStepIndex = useMemo(\n        () => steps.findIndex(({ start }) => elapsed < start) - 1,\n        [elapsed]\n    );\n\n    // Compute the actual current step:\n    const currentStep = useMemo(() => steps[currentStepIndex], [\n        currentStepIndex,\n    ]);\n\n    // Compute how much time is remaining in the current step\n    const currentStepRemaining = useMemo(\n        () => steps[currentStepIndex].duration,\n        [currentStepIndex, elapsed]\n    );\n\n    // Run the timer:\n    const tick = () => setElapsed((elapsed) => (elapsed += STEPSIZE));\n    useInterval(tick, isRunning && !isComplete ? STEPSIZE : null);\n\n    // Expose some helper methods to manipulate the timer:\n    const pause = useCallback(() => setIsRunning(false), []);\n    const reset = useCallback(() => {\n        setElapsed(0);\n        setIsRunning(false);\n    }, []);\n    const start = useCallback(() => setIsRunning(true), []);\n    const toggle = useCallback(\n        () => setIsRunning((isRunning) => !isRunning),\n        []\n    );\n\n    return {\n        currentStep,\n        currentStepIndex,\n        currentStepRemaining,\n        elapsed,\n        isComplete,\n        isRunning,\n        pause,\n        remaining,\n        reset,\n        start,\n        toggle,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}